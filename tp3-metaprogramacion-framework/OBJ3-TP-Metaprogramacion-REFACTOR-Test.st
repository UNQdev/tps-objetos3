TestCase subclass: #TestFullRenameProperty	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OBJ3-TP-Metaprogramacion-Test'!!TestFullRenameProperty methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/5/2014 01:20'!setUp	| clasePrueba clasePaquete claseFueraDelPaquete |	clasePrueba := Object subclass: #Prueba						instanceVariableNames: 'propiedad_viejoNombre'						classVariableNames: ''						poolDictionaries: ''						category: self class category.	"accessors"	clasePrueba compile: 'propiedad_viejoNombre		^ propiedad_viejoNombre'.	clasePrueba compile: 'propiedad_viejoNombre: anObject 		propiedad_viejoNombre := anObject'.	"metodos con referencia a los accessors"	clasePrueba compile: 'metodoConReferenciaASetter		self propiedad_viejoNombre'.	clasePrueba compile: 'metodoConReferenciaAGetter		self propiedad_viejoNombre: 2'.	clasePaquete := Object subclass: #Prueba2							instanceVariableNames: ''							classVariableNames: ''							poolDictionaries: ''							category: self class category.	"metodos con referencia a los accessors de la claseclasePrueba"	clasePaquete compile: 'metodoConReferencia1: clasePrueba		^ clasePrueba propiedad_viejoNombre'.	clasePaquete compile: 'metodoConReferencia2: clasePrueba		^ clasePrueba propiedad_viejoNombre: 5'.	"metodo sin referencia a los accessors de la clasePrueba"	clasePaquete compile: 'metodoSinReferencia		^ 5'.	claseFueraDelPaquete := Object subclass: #Prueba3							instanceVariableNames: ''							classVariableNames: ''							poolDictionaries: ''							category: 'OBJ3-TP-Metaprogramacion-BORRAR'.			"metodo con referencia a los accesors de la clasePrueba"	claseFueraDelPaquete compile: 'metodoConReferencia3: clasePrueba 		clasePrueba propiedad_viejoNombre: 2.		^ clasePrueba propiedad_viejoNombre'.! !!TestFullRenameProperty methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/4/2014 21:48'!tearDown	(Smalltalk at: #Prueba) removeFromSystem.	(Smalltalk at: #Prueba2) removeFromSystem.	(Smalltalk at: #Prueba3) removeFromSystem.! !!TestFullRenameProperty methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/5/2014 23:58'!testCase	| claseAModificar clasePaquete claseFueraDelPaquete |	claseAModificar := Smalltalk at: #Prueba.	clasePaquete := Smalltalk at: #Prueba2.	claseFueraDelPaquete := Smalltalk at: #Prueba3.		FullRenameProperty new		clase: claseAModificar;		propiedad: 'propiedad_viejoNombre';		nuevoNombre: 'propiedad_nuevoNombre';		execute.	"Verificaciones sobre la propiedad de la clase"	self assert: (claseAModificar hasInstVarNamed: 'propiedad_nuevoNombre').	self deny: (claseAModificar hasInstVarNamed: 'propiedad_viejoNombre').	"la propiedad fue correctamente renombrada y no quedan residuos"		"Verificaciones sobre el getter de la propiedad"	self assert: (claseAModificar canUnderstand: #propiedad_nuevoNombre).	self deny: (claseAModificar canUnderstand: #propiedad_viejoNombre).	"el getter fue correctamente renombrado y no quedan residuos"	self assert: ((claseAModificar >> #propiedad_nuevoNombre) hasInstVarRef: 'propiedad_nuevoNombre').	self deny: ((claseAModificar >> #propiedad_nuevoNombre) hasInstVarRef: 'propiedad_viejoNombre').	"el getter es consistente y no quedan residuos"		"Verificaciones sobre el setter de la propiedad"		self assert: (claseAModificar canUnderstand: 'propiedad_nuevoNombre:').	self deny: (claseAModificar canUnderstand: 'propiedad_viejoNombre:').	"el setter fue correctamente renombrado y no quedan residuos"	self assert: ((claseAModificar >> #propiedad_nuevoNombre:) hasInstVarRef: 'propiedad_nuevoNombre').	self deny: ((claseAModificar >> #propiedad_nuevoNombre:) hasInstVarRef: 'propiedad_viejoNombre').	"el setter es consistente y no quedan residuos"		"Verificaciones sobre metodos con referencias a accessors de la propiedad"	self assert: ((claseAModificar >> #metodoConReferenciaAGetter) hasReferencesTo: #propiedad_nuevoNombre).	self deny: ((claseAModificar  >> #metodoConReferenciaAGetter) hasReferencesTo: #propiedad_viejoNombre).	self assert: ((claseAModificar >> #metodoConReferenciaASetter) hasReferencesTo: #propiedad_nuevoNombre:).	self deny: ((claseAModificar >> #metodoConReferenciaASetter) hasReferencesTo: #propiedad_viejoNombre:).	"el codigo de los metodos fue correctamente modificado y no quedan residuos"		"Verificaciones sobre metodos de otra clase, perteneciente al mismo paquete con referencias a los accessors de la propiedad"	self assert: ((clasePaquete >> #metodoConReferencia1) hasReferencesTo: #propiedad_nuevoNombre).	self deny: ((clasePaquete >> #metodoConReferencia1) hasReferencesTo: #propiedad_viejoNombre).	self assert: ((clasePaquete >> #metodoConReferencia2) hasReferencesTo: #propiedad_nuevoNombre:).	self deny: ((clasePaquete >> #metodoConReferencia2) hasReferencesTo: #propiedad_viejoNombre:).	"el codigo de los metodos fue correctamente modificado y no quedan residuos"		"Verificaciones sobre metodos"	self deny: ((claseFueraDelPaquete >> #metodoConReferencia3) hasReferencesTo: #propiedad_nuevoNombre:).	self assert: ((claseFueraDelPaquete >> #metodoConReferencia3) hasReferencesTo: #propiedad_viejoNombre:).	"el codigo no fue modificado ya que no pertenece al paquete de la clase donde se renombro la propiedad"! !TestCase subclass: #TestGenericEquals	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OBJ3-TP-Metaprogramacion-Test'!!TestGenericEquals methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/5/2014 15:18'!setUp	| clasePrueba |	clasePrueba := Object subclass: #Persona 						uses: GenericEquals						instanceVariableNames: 'nombre edad'						classVariableNames: ''						poolDictionaries: ''						category: self class category.		clasePrueba compile: 'nombre		^ nombre'.	clasePrueba compile: 'nombre: unNombre		nombre := unNombre'.	clasePrueba compile: 'edad		^ edad'.	clasePrueba compile: 'edad: unValor		edad := unValor'.			clasePrueba compile: 'keyProperties		^ #(nombre edad)'.	! !!TestGenericEquals methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/5/2014 01:41'!tearDown	(Smalltalk at: #Persona) removeFromSystem.! !!TestGenericEquals methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/5/2014 02:14'!testCase	| persona1 persona2 persona3 persona4 |		persona1 := (Smalltalk at: #Persona) new nombre: 'Marcelo'; edad: 27.	persona2 := (Smalltalk at: #Persona) new nombre: 'Marcelo'; edad: 27.	self assert: (persona1 = persona2).		persona3 := (Smalltalk at: #Persona) new nombre: 'Marce'; edad: 27.	persona4 := (Smalltalk at: #Persona) new nombre: 'Marcelo'; edad: 26.	self deny: (persona1 = persona3).	self deny: (persona1 = persona4).	! !TestCase subclass: #TestSimpleRenameProperty	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OBJ3-TP-Metaprogramacion-Test'!!TestSimpleRenameProperty methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/5/2014 01:57'!setUp	| claseDePrueba |	claseDePrueba := Object subclass: #Prueba						instanceVariableNames: 'propiedad_viejoNombre'						classVariableNames: ''						poolDictionaries: ''						category: self class category.	"accessors"	claseDePrueba compile: 'propiedad_viejoNombre		^ propiedad_viejoNombre'.	claseDePrueba compile: 'propiedad_viejoNombre: anObject 		propiedad_viejoNombre := anObject'.! !!TestSimpleRenameProperty methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/6/2014 00:03'!tearDown	(Smalltalk at: #Prueba) removeFromSystem.! !!TestSimpleRenameProperty methodsFor: 'as yet unclassified' stamp: 'MarceloRubini 5/5/2014 23:58'!testCase	| claseAModificar |	claseAModificar := Smalltalk at: #Prueba.		SimpleRenameProperty new		clase: claseAModificar;		propiedad: 'propiedad_viejoNombre';		nuevoNombre: 'propiedad_nuevoNombre';		renombrarPropiedad.	"Verificaciones sobre la propiedad de la clase"	self assert: (claseAModificar hasInstVarNamed: 'propiedad_nuevoNombre').	self deny: (claseAModificar hasInstVarNamed: 'propiedad_viejoNombre').	"la propiedad fue correctamente renombrada y no quedan residuos"		"Verificaciones sobre el getter de la propiedad"	self assert: (claseAModificar canUnderstand: #propiedad_nuevoNombre).	self deny: (claseAModificar canUnderstand: #propiedad_viejoNombre).	"el getter fue correctamente renombrado y no quedan residuos"			"Verificaciones sobre el setter de la propiedad"		self assert: (claseAModificar canUnderstand: #propiedad_nuevoNombre:).	self deny: (claseAModificar canUnderstand: #propiedad_viejoNombre:).	"el setter fue correctamente renombrado y no quedan residuos"	"FALLAN porque (clase >> #selector) no entiende el mensaje hasInstVarRef (?????)		self assert: ((claseAModificar >> #propiedad_nuevoNombre) hasInstVarRef: 'propiedad_nuevoNombre').	self deny: ((claseAModificar >> #propiedad_nuevoNombre) hasInstVarRef: 'propiedad_viejoNombre').	self assert: ((claseAModificar >> #propiedad_nuevoNombre:) hasInstVarRef: 'propiedad_nuevoNombre').	self deny: ((claseAModificar >> #propiedad_nuevoNombre:) hasInstVarRef: 'propiedad_viejoNombre').	"! !