/**
 * generated by Xtext
 */
package tp5.dslexterno.xtext.validation;

import com.google.common.base.Objects;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import tp5.dslexterno.xtext.planificacionMaterias.Asignacion_Diaria;
import tp5.dslexterno.xtext.planificacionMaterias.Asignacion_Materia;
import tp5.dslexterno.xtext.planificacionMaterias.Aula;
import tp5.dslexterno.xtext.planificacionMaterias.Dedicacion;
import tp5.dslexterno.xtext.planificacionMaterias.Dia;
import tp5.dslexterno.xtext.planificacionMaterias.Disponibilidad;
import tp5.dslexterno.xtext.planificacionMaterias.Exclusiva;
import tp5.dslexterno.xtext.planificacionMaterias.Horario;
import tp5.dslexterno.xtext.planificacionMaterias.Materia;
import tp5.dslexterno.xtext.planificacionMaterias.Planificacion;
import tp5.dslexterno.xtext.planificacionMaterias.PlanificacionMateriasPackage;
import tp5.dslexterno.xtext.planificacionMaterias.Profesor;
import tp5.dslexterno.xtext.planificacionMaterias.Rango_Horario;
import tp5.dslexterno.xtext.planificacionMaterias.Recurso;
import tp5.dslexterno.xtext.planificacionMaterias.Semi;
import tp5.dslexterno.xtext.planificacionMaterias.Simple;
import tp5.dslexterno.xtext.validation.AbstractPlanificacionMateriasValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class PlanificacionMateriasValidator extends AbstractPlanificacionMateriasValidator {
  /**
   * Validaciones iniciales
   */
  @Check
  public void validarCargaHorariaDocente(final Asignacion_Materia asignacionMateria) {
    EObject _eContainer = asignacionMateria.eContainer();
    EList<Asignacion_Materia> listaDeAsignaciones = ((Planificacion) _eContainer).getAsignacionesDeMaterias();
    Profesor profesor = asignacionMateria.getProfesor();
    int _cantMateriasSegunDedicacion = this.cantMateriasSegunDedicacion(profesor);
    List<Asignacion_Materia> _materiasAsignadasA = this.materiasAsignadasA(listaDeAsignaciones, profesor);
    int _size = _materiasAsignadasA.size();
    boolean _lessThan = (_cantMateriasSegunDedicacion < _size);
    if (_lessThan) {
      List<Asignacion_Materia> _materiasAsignadasA_1 = this.materiasAsignadasA(listaDeAsignaciones, profesor);
      int _size_1 = _materiasAsignadasA_1.size();
      int _cantMateriasSegunDedicacion_1 = this.cantMateriasSegunDedicacion(profesor);
      final int diferenciaMaterias = (_size_1 - _cantMateriasSegunDedicacion_1);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("El profesor ");
      String _name = profesor.getName();
      String _upperCase = _name.toUpperCase();
      _builder.append(_upperCase, "");
      _builder.append(" supera en ");
      _builder.append(diferenciaMaterias, "");
      _builder.append(" materia/s el limite de su dedicacion");
      this.error(_builder.toString(), asignacionMateria, 
        PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__PROFESOR);
    }
  }
  
  @Check
  public void validarTodasLasMateriasAsignadas(final Planificacion planificacion) {
    final EList<Materia> materiasADictar = planificacion.getMateriasADictar();
    EList<Asignacion_Materia> _asignacionesDeMaterias = planificacion.getAsignacionesDeMaterias();
    final Function1<Asignacion_Materia, Materia> _function = new Function1<Asignacion_Materia, Materia>() {
      public Materia apply(final Asignacion_Materia it) {
        return it.getMateria();
      }
    };
    final List<Materia> materiasAsignadas = ListExtensions.<Asignacion_Materia, Materia>map(_asignacionesDeMaterias, _function);
    boolean _containsAll = materiasAsignadas.containsAll(materiasADictar);
    boolean _not = (!_containsAll);
    if (_not) {
      final Function1<Materia, Boolean> _function_1 = new Function1<Materia, Boolean>() {
        public Boolean apply(final Materia it) {
          boolean _contains = materiasAsignadas.contains(it);
          return Boolean.valueOf((!_contains));
        }
      };
      Iterable<Materia> _filter = IterableExtensions.<Materia>filter(materiasADictar, _function_1);
      final Function1<Materia, String> _function_2 = new Function1<Materia, String>() {
        public String apply(final Materia it) {
          return it.getName();
        }
      };
      final Iterable<String> diferenciaMaterias = IterableExtensions.<Materia, String>map(_filter, _function_2);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Falta asignar la/s siguiente/s materia/s: ");
      _builder.append(diferenciaMaterias, "");
      this.error(_builder.toString(), planificacion, 
        PlanificacionMateriasPackage.Literals.PLANIFICACION__MATERIAS_ADICTAR);
    }
  }
  
  @Check
  public void validarCargaHorariaMateria(final Asignacion_Materia asignacion) {
    int _horasAsignadas = this.horasAsignadas(asignacion);
    Materia _materia = asignacion.getMateria();
    int _cantidadHorasSemanales = _materia.getCantidadHorasSemanales();
    final int diferenciaHoras = (_horasAsignadas - _cantidadHorasSemanales);
    if ((diferenciaHoras < 0)) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("A la materia ");
      Materia _materia_1 = asignacion.getMateria();
      String _name = _materia_1.getName();
      String _upperCase = _name.toUpperCase();
      _builder.append(_upperCase, "");
      _builder.append(" le faltan asignar ");
      String _string = Integer.valueOf(diferenciaHoras).toString();
      _builder.append(_string, "");
      _builder.append(" horas");
      this.error(_builder.toString(), asignacion, 
        PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__MATERIA);
    }
    if ((diferenciaHoras > 0)) {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("La materia ");
      Materia _materia_2 = asignacion.getMateria();
      String _name_1 = _materia_2.getName();
      String _upperCase_1 = _name_1.toUpperCase();
      _builder_1.append(_upperCase_1, "");
      _builder_1.append(" excede en ");
      String _string_1 = Integer.valueOf(diferenciaHoras).toString();
      _builder_1.append(_string_1, "");
      _builder_1.append(" horas su carga semanal");
      this.error(_builder_1.toString(), asignacion, 
        PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__MATERIA);
    }
  }
  
  @Check
  public void validarCompatibilidadAulaMateria(final Asignacion_Materia asignacion) {
    final Aula aula = asignacion.getAula();
    EList<Recurso> _recusos = aula.getRecusos();
    final Function1<Recurso, String> _function = new Function1<Recurso, String>() {
      public String apply(final Recurso it) {
        return it.getName();
      }
    };
    final List<String> recursosAula = ListExtensions.<Recurso, String>map(_recusos, _function);
    Materia _materia = asignacion.getMateria();
    EList<Recurso> _requerimientos = _materia.getRequerimientos();
    final Function1<Recurso, String> _function_1 = new Function1<Recurso, String>() {
      public String apply(final Recurso it) {
        return it.getName();
      }
    };
    final List<String> requerimientosMateria = ListExtensions.<Recurso, String>map(_requerimientos, _function_1);
    boolean _containsAll = recursosAula.containsAll(requerimientosMateria);
    boolean _not = (!_containsAll);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      String _name = aula.getName();
      String _upperCase = _name.toUpperCase();
      _builder.append(_upperCase, "");
      _builder.append("  no cuenta con los recursos requeridos por la materia ");
      Materia _materia_1 = asignacion.getMateria();
      String _name_1 = _materia_1.getName();
      String _upperCase_1 = _name_1.toUpperCase();
      _builder.append(_upperCase_1, "");
      this.error(_builder.toString(), asignacion, 
        PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__AULA);
    }
  }
  
  /**
   * Validaciones de puntos bonus
   */
  @Check
  public void validarCapacidadAula(final Asignacion_Materia asignacion) {
    final int alumnosInscriptos = asignacion.getAlumnosInscriptos();
    Aula _aula = asignacion.getAula();
    int _capacidad = _aula.getCapacidad();
    boolean _lessThan = (_capacidad < alumnosInscriptos);
    if (_lessThan) {
      StringConcatenation _builder = new StringConcatenation();
      Aula _aula_1 = asignacion.getAula();
      String _name = _aula_1.getName();
      String _upperCase = _name.toUpperCase();
      _builder.append(_upperCase, "");
      _builder.append("  no tiene capacidad para la cantidad de alumnos inscriptos.");
      this.error(_builder.toString(), asignacion, 
        PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__ALUMNOS_INSCRIPTOS);
    }
  }
  
  /**
   * Dada la reflexion llevada a cabo mas abajo en la validacion/verificacion extra, esta validacion/verificacion SOLICITADA por el enunciado no me satisface
   * Queda a vuestro gusto si persiste o se va
   */
  public boolean noEstaDisponibleDia(final Profesor profesor, final Dia diaMateria) {
    boolean _xblockexpression = false;
    {
      final EList<Disponibilidad> disponibilidades = profesor.getDisponibilidad();
      final Function1<Disponibilidad, Boolean> _function = new Function1<Disponibilidad, Boolean>() {
        public Boolean apply(final Disponibilidad disp) {
          Dia _dia = disp.getDia();
          return Boolean.valueOf(PlanificacionMateriasValidator.this.diaIncluido(_dia, diaMateria));
        }
      };
      Iterable<Disponibilidad> _filter = IterableExtensions.<Disponibilidad>filter(disponibilidades, _function);
      int _size = IterableExtensions.size(_filter);
      _xblockexpression = (_size > 0);
    }
    return _xblockexpression;
  }
  
  public boolean diaIncluido(final Dia dia, final Dia diaMateria) {
    return Objects.equal(dia, diaMateria);
  }
  
  /**
   * Validaciones extras
   */
  @Check
  public void validarDiasDisponibles(final Profesor profesor) {
    EList<Disponibilidad> _disponibilidad = profesor.getDisponibilidad();
    final Function1<Disponibilidad, Dia> _function = new Function1<Disponibilidad, Dia>() {
      public Dia apply(final Disponibilidad it) {
        return it.getDia();
      }
    };
    final List<Dia> diasDisponibles = ListExtensions.<Disponibilidad, Dia>map(_disponibilidad, _function);
    final Function1<Dia, Boolean> _function_1 = new Function1<Dia, Boolean>() {
      public Boolean apply(final Dia d) {
        final Function1<Dia, Dia> _function = new Function1<Dia, Dia>() {
          public Dia apply(final Dia it) {
            return d;
          }
        };
        List<Dia> _map = ListExtensions.<Dia, Dia>map(diasDisponibles, _function);
        int _size = _map.size();
        return Boolean.valueOf((_size > 1));
      }
    };
    final Iterable<Dia> repetidos = IterableExtensions.<Dia>filter(diasDisponibles, _function_1);
    int _size = IterableExtensions.size(repetidos);
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("El/Los dia/s ");
      final Procedure1<Dia> _function_2 = new Procedure1<Dia>() {
        public void apply(final Dia it) {
          it.toString();
        }
      };
      IterableExtensions.<Dia>forEach(repetidos, _function_2);
      _builder.append(" estan repetidos ");
      this.error(_builder.toString(), profesor, 
        PlanificacionMateriasPackage.Literals.PROFESOR__DISPONIBILIDAD);
    }
  }
  
  /**
   * Zafa, pero no son exactos. Existe la posibilidad de que se hable del mismo dia en distintos horarios.
   * un ejemplo rapido:
   * 
   * puede Lunes { de 8:00 a 12:00 }
   * puede Lunes { de 14:00 a 18:00 }
   * 
   * Entonces,
   * diasDisponibles.map[d].size > 1! ---> TRUE
   * pero no porque se esten definiendo dos veces al pedo
   * 
   * Habria que comparar los rangos o, a cada disponibilidad dentro de la lista de disponibilidades, definirlo como una lista de rangosHorario
   * Osea:
   * 
   * Disponibilidad:
   * 'puede:' dia=Dia (rangosHorario+=Rango_Horario)? |
   * 'no puede' dia=Dia (rangosHorario+=Rango_Horario)?
   * 
   * Termina siendo un trastorno...
   */
  public Object validarHorariosDisponibles(final Profesor profesor) {
    return null;
  }
  
  /**
   * Comportamiento agregado via extension methods
   */
  public Planificacion planificacion(final Materia materia) {
    EObject _eContainer = materia.eContainer();
    EObject _eContainer_1 = ((Asignacion_Materia) _eContainer).eContainer();
    EObject _eContainer_2 = ((Asignacion_Diaria) _eContainer_1).eContainer();
    return ((Planificacion) _eContainer_2);
  }
  
  public int horasAsignadas(final Asignacion_Materia asignacion) {
    Integer _xblockexpression = null;
    {
      final EList<Asignacion_Diaria> asignacionesDiarias = asignacion.getAsignacionesDiarias();
      final Function1<Asignacion_Diaria, Integer> _function = new Function1<Asignacion_Diaria, Integer>() {
        public Integer apply(final Asignacion_Diaria it) {
          Rango_Horario _rangoHorario = it.getRangoHorario();
          return Integer.valueOf(PlanificacionMateriasValidator.this.cantidadDeHoras(_rangoHorario));
        }
      };
      List<Integer> _map = ListExtensions.<Asignacion_Diaria, Integer>map(asignacionesDiarias, _function);
      final Function2<Integer, Integer, Integer> _function_1 = new Function2<Integer, Integer, Integer>() {
        public Integer apply(final Integer sum, final Integer cantHoras) {
          return Integer.valueOf(((sum).intValue() + (cantHoras).intValue()));
        }
      };
      _xblockexpression = IterableExtensions.<Integer>reduce(_map, _function_1);
    }
    return (_xblockexpression).intValue();
  }
  
  public int cantidadDeHoras(final Rango_Horario horario) {
    Horario _horaFinal = horario.getHoraFinal();
    int _hora = _horaFinal.getHora();
    Horario _horaInicio = horario.getHoraInicio();
    int _hora_1 = _horaInicio.getHora();
    return (_hora - _hora_1);
  }
  
  public List<Asignacion_Materia> materiasAsignadasA(final List<Asignacion_Materia> listaAsignaciones, final Profesor profesor0) {
    final Function1<Asignacion_Materia, Boolean> _function = new Function1<Asignacion_Materia, Boolean>() {
      public Boolean apply(final Asignacion_Materia it) {
        Profesor _profesor = it.getProfesor();
        return Boolean.valueOf(Objects.equal(_profesor, profesor0));
      }
    };
    Iterable<Asignacion_Materia> _filter = IterableExtensions.<Asignacion_Materia>filter(listaAsignaciones, _function);
    return IterableExtensions.<Asignacion_Materia>toList(_filter);
  }
  
  public int cantMateriasSegunDedicacion(final Profesor profesor) {
    Dedicacion _dedicacion = profesor.getDedicacion();
    return this.cantidadMaterias(_dedicacion);
  }
  
  protected int _cantidadMaterias(final Simple dedicacion) {
    return 1;
  }
  
  protected int _cantidadMaterias(final Semi dedicacion) {
    return 2;
  }
  
  protected int _cantidadMaterias(final Exclusiva dedicacion) {
    return 5;
  }
  
  public String toString(final Rango_Horario rangoHorario) {
    Horario _horaInicio = rangoHorario.getHoraInicio();
    int _hora = _horaInicio.getHora();
    String _string = Integer.valueOf(_hora).toString();
    String _plus = (_string + ":");
    Horario _horaFinal = rangoHorario.getHoraFinal();
    int _hora_1 = _horaFinal.getHora();
    String _string_1 = Integer.valueOf(_hora_1).toString();
    return (_plus + _string_1);
  }
  
  public int cantidadMaterias(final Dedicacion dedicacion) {
    if (dedicacion instanceof Exclusiva) {
      return _cantidadMaterias((Exclusiva)dedicacion);
    } else if (dedicacion instanceof Semi) {
      return _cantidadMaterias((Semi)dedicacion);
    } else if (dedicacion instanceof Simple) {
      return _cantidadMaterias((Simple)dedicacion);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(dedicacion).toString());
    }
  }
}
