/*
 * generated by Xtext
 */
package tp5.dslexterno.xtext.validation

import java.util.List
import org.eclipse.xtext.validation.Check
import tp5.dslexterno.xtext.planificacionMaterias.Asignacion_Diaria
import tp5.dslexterno.xtext.planificacionMaterias.Asignacion_Materia
import tp5.dslexterno.xtext.planificacionMaterias.Aula
import tp5.dslexterno.xtext.planificacionMaterias.Exclusiva
import tp5.dslexterno.xtext.planificacionMaterias.Horario
import tp5.dslexterno.xtext.planificacionMaterias.Materia
import tp5.dslexterno.xtext.planificacionMaterias.Model
import tp5.dslexterno.xtext.planificacionMaterias.Planificacion
import tp5.dslexterno.xtext.planificacionMaterias.PlanificacionMateriasPackage
import tp5.dslexterno.xtext.planificacionMaterias.Profesor
import tp5.dslexterno.xtext.planificacionMaterias.Rango_Horario
import tp5.dslexterno.xtext.planificacionMaterias.Semi
import tp5.dslexterno.xtext.planificacionMaterias.Simple
import tp5.dslexterno.xtext.planificacionMaterias.Dia

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PlanificacionMateriasValidator extends AbstractPlanificacionMateriasValidator {


	/*
	 * Validaciones iniciales
	 */
	@Check
	def validarCargaHorariaDocente(Asignacion_Materia asignacionMateria){
		var listaDeAsignaciones = (asignacionMateria.eContainer as Planificacion).asignacionesDeMaterias
		var profesor = asignacionMateria.profesor
		if(profesor.cantMateriasSegunDedicacion < listaDeAsignaciones.materiasAsignadasA(profesor).size){
			val diferenciaMaterias = listaDeAsignaciones.materiasAsignadasA(profesor).size - profesor.cantMateriasSegunDedicacion
			error('''El profesor «profesor.name.toUpperCase» supera en «diferenciaMaterias» materia/s el limite de su dedicacion''', asignacionMateria,
				PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__PROFESOR)
		}
	}
	
	@Check
	def validarTodasLasMateriasAsignadas(Planificacion planificacion){
		val materiasADictar = planificacion.materiasADictar
		val materiasAsignadas = planificacion.asignacionesDeMaterias.map[materia]
		if(!materiasAsignadas.containsAll(materiasADictar)){
			val diferenciaMaterias = materiasADictar.filter[!materiasAsignadas.contains(it)].map[name]			
			error('''Falta asignar la/s siguiente/s materia/s: «diferenciaMaterias»''', planificacion,
				PlanificacionMateriasPackage.Literals.PLANIFICACION__MATERIAS_ADICTAR)
		}
	}
	
	@Check
	def validarCargaHorariaMateria(Asignacion_Materia asignacion){
		val diferenciaHoras = asignacion.horasAsignadas - asignacion.materia.cantidadHorasSemanales
		if (diferenciaHoras < 0){
			error('''A la materia «asignacion.materia.name.toUpperCase» le faltan asignar «diferenciaHoras.toString» horas''', asignacion,
				PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__MATERIA)
		} 
		if(diferenciaHoras > 0){
			error('''La materia «asignacion.materia.name.toUpperCase» excede en «diferenciaHoras.toString» horas su carga semanal''', asignacion,
				PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__MATERIA)
		}
	}
	
	@Check
	def validarCompatibilidadAulaMateria(Asignacion_Materia asignacion){
		val aula = asignacion.aula
		val recursosAula = aula.recusos.map[name]
		val requerimientosMateria = asignacion.materia.requerimientos.map[name]
		if (!recursosAula.containsAll(requerimientosMateria)){
			error('''«aula.name.toUpperCase»  no cuenta con los recursos requeridos por la materia «asignacion.materia.name.toUpperCase»''', asignacion,
				PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__AULA)
		}
	}
	
//	@Check
	// TODO: verificar este engendro :P
//	def validarSuperposicionEntreMaterias(Asignacion_Materia asignacionMateria){
//		val materiasMismoDia = ((materia.eContainer as Asignacion_Materia).eContainer as Asignacion_Diaria).asignacionesDeMaterias
//		val materiasSuperpuestas = materia.seSuperponeCon(materiasMismoDia)
//		if(materiasSuperpuestas.size > 0){
//			//NO DARLE BOLA AL MENSAJE DE ERROR, SE PUEDE SIMPLICAR
//			error('''«materia.name.toUpperCase» se superpone con: «materiasSuperpuestas.forEach[m | m.name.toUpperCase]»''', (materia.eContainer as Asignacion_Materia),
//				PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__RANGO_HORARIO)
//		}
//	}	
	// TODO: Llevarse todos estos extension methods para abajo...
//	def List<Materia> seSuperponeCon(Materia materia, List<Asignacion_Materia> materiasMismoDia){
//		val horariosMateria = (materia.eContainer as Asignacion_Materia).rangoHorario
//		materiasMismoDia.filter[am | am.materiaConSuperposicionHoraria(horariosMateria)].map[materia].toList
//	}
//	def boolean materiaConSuperposicionHoraria(Asignacion_Materia asignacion, Rango_Horario rangoHorario){
//		asignacion.rangoHorario.sePisaCon(rangoHorario)
//	}
//	def boolean sePisaCon(Rango_Horario rangoHorario1, Rango_Horario rangoHorario2){
//		rangoHorario2.horaInicio.estaEntre(rangoHorario1) || rangoHorario2.horaFinal.estaEntre(rangoHorario1) 		
//	}	
//	def boolean estaEntre(Horario horario, Rango_Horario rangoHorario){
//		// TODO: generar una lista con las HORAS del rango horario y hacerle un contains con la HORA del horario :)
//		true
//	}
		
	/*
	 * Validaciones de puntos bonus
	 */
	@Check
	def validarCapacidadAula(Asignacion_Materia asignacion){
		val alumnosInscriptos = asignacion.alumnosInscriptos
		if(asignacion.aula.capacidad < alumnosInscriptos){
			error('''«asignacion.aula.name.toUpperCase»  no tiene capacidad para la cantidad de alumnos inscriptos.''', asignacion,
				PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__ALUMNOS_INSCRIPTOS)
		}
	}
	
//	@Check
//	def validarDisponibilidadProfesor(Materia materia){
//		val profesor = materia.profesor
//		val horariosMateria = materia.asignacion.rangoHorario
//		val diaMateria = (materia.asignacion.eContainer as Asignacion_Diaria).dia
//		if(profesor.noEstaDisponibleDia(diaMateria)){
//			error('''«profesor.name.toUpperCase» no tiene disponibilidad el dia «diaMateria.toString»''', materia.asignacion,
//				PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__PROFESOR)
//		}
//		if(profesor.noEstaDisponibleHorario(horariosMateria)){
//			error('''«profesor.name.toUpperCase» no tiene disponibilidad en el horario «horariosMateria.toString»''', materia.asignacion,
//				PlanificacionMateriasPackage.Literals.ASIGNACION_MATERIA__PROFESOR)
//		}
//	} 
	/*
	 * Dada la reflexion llevada a cabo mas abajo en la validacion/verificacion extra, esta validacion/verificacion SOLICITADA por el enunciado no me satisface
	 * Queda a vuestro gusto si persiste o se va
	 */
	
	//Se que es una cagada que este duplicado, pero es la unica manera que se me ocurre a las (casi) 2AM de mostrar errores "COPADOS" ¬¬
//	def boolean noEstaDisponibleHorario(Profesor profesor, Rango_Horario horarioMateria){
//		val disponibilidades = profesor.disponibilidad
//		disponibilidades.filter[disp | disp.rangoHorario.rangoIncluido(horarioMateria)].size > 0
//	}
	def boolean noEstaDisponibleDia(Profesor profesor, Dia diaMateria){
		val disponibilidades = profesor.disponibilidad
		disponibilidades.filter[disp | disp.dia.diaIncluido(diaMateria)].size > 0 
	}
		
//	def boolean rangoIncluido(Rango_Horario rangoHorario, Rango_Horario rangoHorarioMateria){
//		rangoHorarioMateria.horaInicio.estaEntre(rangoHorario) && rangoHorarioMateria.horaFinal.estaEntre(rangoHorario)
//	}	
	def boolean diaIncluido(Dia dia, Dia diaMateria) {
		dia == diaMateria
	}
		
	/*
	 * Validaciones extras
	 */
	@Check
	def validarDiasDisponibles(Profesor profesor){
		val diasDisponibles = profesor.disponibilidad.map[dia]
		val repetidos = diasDisponibles.filter[d | diasDisponibles.map[d].size > 1] 
		if(repetidos.size > 0){
			error('''El/Los dia/s «repetidos.forEach[toString]» estan repetidos ''', profesor,
				PlanificacionMateriasPackage.Literals.PROFESOR__DISPONIBILIDAD)
		}
	} /* Zafa, pero no son exactos. Existe la posibilidad de que se hable del mismo dia en distintos horarios.
	   * un ejemplo rapido:
	   * 
	   * puede Lunes { de 8:00 a 12:00 }
	   * puede Lunes { de 14:00 a 18:00 }
	   * 
	   * Entonces,
	   * diasDisponibles.map[d].size > 1! ---> TRUE
	   * pero no porque se esten definiendo dos veces al pedo
	   * 
	   * Habria que comparar los rangos o, a cada disponibilidad dentro de la lista de disponibilidades, definirlo como una lista de rangosHorario
	   * Osea:
	   * 
	   * Disponibilidad:
	   * 'puede:' dia=Dia (rangosHorario+=Rango_Horario)? |
	   * 'no puede' dia=Dia (rangosHorario+=Rango_Horario)?
	   * 
	   * Termina siendo un trastorno...
	   */
	def validarHorariosDisponibles(Profesor profesor){
		// TODO: ON HOLD
	}
	
	/*
	 * Comportamiento agregado via extension methods
	 */	
	
	// MATERIA
	def Planificacion planificacion(Materia materia){
		((materia.eContainer as Asignacion_Materia).eContainer as Asignacion_Diaria).eContainer as Planificacion
	}
//	def Asignacion_Materia asignacion(Materia materia){
//		materia.eContainer as Asignacion_Materia
//	}	
//	def Profesor profesor(Materia materia){
//		materia.asignacion.profesor
//	}
	def int horasAsignadas(Asignacion_Materia asignacion) {
		val asignacionesDiarias = asignacion.asignacionesDiarias
		asignacionesDiarias.map[rangoHorario.cantidadDeHoras].reduce[sum, cantHoras | sum + cantHoras]
	}
	
	def int cantidadDeHoras(Rango_Horario horario){
		horario.horaFinal.hora - horario.horaInicio.hora
	}
	
	// PROFESOR
	def List<Asignacion_Materia> materiasAsignadasA(List<Asignacion_Materia> listaAsignaciones, Profesor profesor0){
		listaAsignaciones.filter[profesor == profesor0].toList
	}
	def int cantMateriasSegunDedicacion(Profesor profesor) {
		profesor.dedicacion.cantidadMaterias
	}
	
	// DEDICACION
	def dispatch int cantidadMaterias(Simple dedicacion) { return 1 }
	def dispatch int cantidadMaterias(Semi dedicacion) { return 2 }
	def dispatch int cantidadMaterias(Exclusiva dedicacion) { return 5 }
	// HORARIOS
	def toString(Rango_Horario rangoHorario){
		rangoHorario.horaInicio.hora.toString + ":" + rangoHorario.horaFinal.hora.toString 
	}
}